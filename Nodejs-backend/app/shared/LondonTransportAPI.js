"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request-promise");
const logger_1 = require("./logger");
class LondonTransportAPI {
    constructor() {
        this.defaultURL = "https://api.tfl.gov.uk/";
        this.appID = "64cafb9b";
        this.key = "1824212fb2a19279eb460255ba35966c";
    }
    getBusLineStations(lineID) {
        return new Promise((resolve, reject) => {
            let url = this.defaultURL + "line/" + lineID + "/StopPoints/";
            let opts = {
                uri: url,
                method: 'GET',
                qs: {
                    app_id: this.appID,
                    app_key: this.key
                }
            };
            request(opts).then((result) => {
                //console.log("Got response from London Transport API: " + result);
                if (result) {
                    let data = JSON.parse(result);
                    if (data.length > 0) {
                        let stationsData = [];
                        for (let station of data) {
                            stationsData.push({
                                id: station.id,
                                name: station.commonName
                            });
                        }
                        resolve(stationsData);
                    }
                }
                else {
                    reject("Can not get bus line stations info from API");
                }
            }).catch(err => {
                logger_1.Logger.log("London Transport API error: ", err);
                reject(err);
            });
        });
    }
    getStationTimeTable(lineID, stationID) {
        return new Promise((resolve, reject) => {
            let url = this.defaultURL + "line/" + lineID + "/Timetable/" + stationID;
            let opts = {
                uri: url,
                method: 'GET',
                qs: {
                    app_id: this.appID,
                    app_key: this.key
                }
            };
            request(opts).then((result) => {
                //console.log("Got time table response from London Transport API: " + result);
                if (result) {
                    let data = JSON.parse(result);
                    //console.log("Got time table response from London Transport API: ", data);
                    if (data.timetable && data.timetable.routes && data.timetable.routes.length === 1) {
                        if (data.timetable.routes[0].schedules && data.timetable.routes[0].schedules.length > 0) {
                            let timeTableData = [];
                            for (let schedule of data.timetable.routes[0].schedules) {
                                let lastHour = (Number(schedule.lastJourney.hour) % 24) + "";
                                let busSchedule = {
                                    date: schedule.name,
                                    first: schedule.firstJourney.hour + ":" + schedule.firstJourney.minute,
                                    last: lastHour + ":" + schedule.lastJourney.minute
                                };
                                timeTableData.push(busSchedule);
                            } //for
                            resolve(timeTableData);
                        }
                        else {
                            reject("Bus line stations time table data error");
                        }
                    }
                    else {
                        reject("Bus line stations time table data error");
                    }
                }
                else {
                    reject("Can not get bus line stations time table info from API");
                }
            }).catch(err => {
                logger_1.Logger.log("London Transport API error: ", err);
                reject(err);
            });
        });
    }
}
exports.LondonTransportAPI = LondonTransportAPI;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTG9uZG9uVHJhbnNwb3J0QVBJLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiTG9uZG9uVHJhbnNwb3J0QVBJLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsMkNBQTRDO0FBQzVDLHFDQUFrQztBQVlsQyxNQUFhLGtCQUFrQjtJQUEvQjtRQUVJLGVBQVUsR0FBVyx5QkFBeUIsQ0FBQztRQUUvQyxVQUFLLEdBQVcsVUFBVSxDQUFDO1FBQzNCLFFBQUcsR0FBVyxrQ0FBa0MsQ0FBQztJQTBGckQsQ0FBQztJQXhGVSxrQkFBa0IsQ0FBQyxNQUFjO1FBRXBDLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7WUFFbkMsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxPQUFPLEdBQUcsTUFBTSxHQUFHLGNBQWMsQ0FBQztZQUU5RCxJQUFJLElBQUksR0FBb0I7Z0JBQ3hCLEdBQUcsRUFBRSxHQUFHO2dCQUNSLE1BQU0sRUFBRSxLQUFLO2dCQUNiLEVBQUUsRUFBRTtvQkFDQSxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUs7b0JBQ2xCLE9BQU8sRUFBRSxJQUFJLENBQUMsR0FBRztpQkFDcEI7YUFDSixDQUFBO1lBRUQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO2dCQUMxQixtRUFBbUU7Z0JBQ25FLElBQUksTUFBTSxFQUFFO29CQUNSLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQzlCLElBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7d0JBQ2YsSUFBSSxZQUFZLEdBQW9CLEVBQUUsQ0FBQzt3QkFDdkMsS0FBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUM7NEJBQ3BCLFlBQVksQ0FBQyxJQUFJLENBQUM7Z0NBQ2QsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFFO2dDQUNkLElBQUksRUFBRSxPQUFPLENBQUMsVUFBVTs2QkFDM0IsQ0FBQyxDQUFBO3lCQUNMO3dCQUNELE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztxQkFDekI7aUJBQ0o7cUJBQUk7b0JBQ0QsTUFBTSxDQUFDLDZDQUE2QyxDQUFDLENBQUM7aUJBQ3pEO1lBRUwsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFO2dCQUNYLGVBQU0sQ0FBQyxHQUFHLENBQUMsOEJBQThCLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ2hELE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQixDQUFDLENBQUMsQ0FBQTtRQUNOLENBQUMsQ0FBQyxDQUFBO0lBQ04sQ0FBQztJQUVNLG1CQUFtQixDQUFDLE1BQWMsRUFBRSxTQUFpQjtRQUV4RCxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1lBRW5DLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxHQUFHLE1BQU0sR0FBRyxhQUFhLEdBQUcsU0FBUyxDQUFDO1lBRXpFLElBQUksSUFBSSxHQUFvQjtnQkFDeEIsR0FBRyxFQUFFLEdBQUc7Z0JBQ1IsTUFBTSxFQUFFLEtBQUs7Z0JBQ2IsRUFBRSxFQUFFO29CQUNBLE1BQU0sRUFBRSxJQUFJLENBQUMsS0FBSztvQkFDbEIsT0FBTyxFQUFFLElBQUksQ0FBQyxHQUFHO2lCQUNwQjthQUNKLENBQUE7WUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQzFCLDhFQUE4RTtnQkFDOUUsSUFBSSxNQUFNLEVBQUU7b0JBQ1IsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDOUIsMkVBQTJFO29CQUMzRSxJQUFHLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBQzt3QkFDN0UsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7NEJBQ25GLElBQUksYUFBYSxHQUFxQixFQUFFLENBQUM7NEJBQ3pDLEtBQUksSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFDO2dDQUNuRCxJQUFJLFFBQVEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQ0FDN0QsSUFBSSxXQUFXLEdBQWE7b0NBQ3hCLElBQUksRUFBRSxRQUFRLENBQUMsSUFBSTtvQ0FDbkIsS0FBSyxFQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU07b0NBQ3JFLElBQUksRUFBRSxRQUFRLEdBQUcsR0FBRyxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUMsTUFBTTtpQ0FDckQsQ0FBQTtnQ0FDRCxhQUFhLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzZCQUNuQyxDQUFBLEtBQUs7NEJBQ04sT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDO3lCQUMxQjs2QkFBSTs0QkFDRCxNQUFNLENBQUMseUNBQXlDLENBQUMsQ0FBQzt5QkFDckQ7cUJBQ0o7eUJBQUk7d0JBQ0QsTUFBTSxDQUFDLHlDQUF5QyxDQUFDLENBQUM7cUJBQ3JEO2lCQUNKO3FCQUFJO29CQUNELE1BQU0sQ0FBQyx3REFBd0QsQ0FBQyxDQUFDO2lCQUNwRTtZQUNMLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDWCxlQUFNLENBQUMsR0FBRyxDQUFDLDhCQUE4QixFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNoRCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaEIsQ0FBQyxDQUFDLENBQUE7UUFDTixDQUFDLENBQUMsQ0FBQTtJQUNOLENBQUM7Q0FDSjtBQS9GRCxnREErRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcmVxdWVzdCA9IHJlcXVpcmUoJ3JlcXVlc3QtcHJvbWlzZScpO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpb257XG4gICAgaWQ/OiBzdHJpbmc7XG4gICAgbmFtZT86IHN0cmluZztcbiAgfVxuZXhwb3J0IGludGVyZmFjZSBTY2hlZHVsZXtcbiAgICBkYXRlPzogc3RyaW5nO1xuICAgIGZpcnN0Pzogc3RyaW5nO1xuICAgIGxhc3Q/OiBzdHJpbmc7XG4gIH1cblxuZXhwb3J0IGNsYXNzIExvbmRvblRyYW5zcG9ydEFQSSB7XG5cbiAgICBkZWZhdWx0VVJMOiBzdHJpbmcgPSBcImh0dHBzOi8vYXBpLnRmbC5nb3YudWsvXCI7XG5cbiAgICBhcHBJRDogc3RyaW5nID0gXCI2NGNhZmI5YlwiO1xuICAgIGtleTogc3RyaW5nID0gXCIxODI0MjEyZmIyYTE5Mjc5ZWI0NjAyNTViYTM1OTY2Y1wiO1xuXG4gICAgcHVibGljIGdldEJ1c0xpbmVTdGF0aW9ucyhsaW5lSUQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMuZGVmYXVsdFVSTCArIFwibGluZS9cIiArIGxpbmVJRCArIFwiL1N0b3BQb2ludHMvXCI7XG5cbiAgICAgICAgICAgIGxldCBvcHRzOiByZXF1ZXN0Lk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJpOiB1cmwsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBxczoge1xuICAgICAgICAgICAgICAgICAgICBhcHBfaWQ6IHRoaXMuYXBwSUQsXG4gICAgICAgICAgICAgICAgICAgIGFwcF9rZXk6IHRoaXMua2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXF1ZXN0KG9wdHMpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJHb3QgcmVzcG9uc2UgZnJvbSBMb25kb24gVHJhbnNwb3J0IEFQSTogXCIgKyByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGEgPSBKU09OLnBhcnNlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGEubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdGlvbnNEYXRhIDogQXJyYXk8U3RhdGlvbj4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgc3RhdGlvbiBvZiBkYXRhKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aW9uc0RhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzdGF0aW9uLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzdGF0aW9uLmNvbW1vbk5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzdGF0aW9uc0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChcIkNhbiBub3QgZ2V0IGJ1cyBsaW5lIHN0YXRpb25zIGluZm8gZnJvbSBBUElcIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJMb25kb24gVHJhbnNwb3J0IEFQSSBlcnJvcjogXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdGF0aW9uVGltZVRhYmxlKGxpbmVJRDogc3RyaW5nLCBzdGF0aW9uSUQ6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMuZGVmYXVsdFVSTCArIFwibGluZS9cIiArIGxpbmVJRCArIFwiL1RpbWV0YWJsZS9cIiArIHN0YXRpb25JRDtcblxuICAgICAgICAgICAgbGV0IG9wdHM6IHJlcXVlc3QuT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmk6IHVybCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHFzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcF9pZDogdGhpcy5hcHBJRCxcbiAgICAgICAgICAgICAgICAgICAgYXBwX2tleTogdGhpcy5rZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlcXVlc3Qob3B0cykudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkdvdCB0aW1lIHRhYmxlIHJlc3BvbnNlIGZyb20gTG9uZG9uIFRyYW5zcG9ydCBBUEk6IFwiICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiR290IHRpbWUgdGFibGUgcmVzcG9uc2UgZnJvbSBMb25kb24gVHJhbnNwb3J0IEFQSTogXCIsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnRpbWV0YWJsZSAmJiBkYXRhLnRpbWV0YWJsZS5yb3V0ZXMgJiYgZGF0YS50aW1ldGFibGUucm91dGVzLmxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihkYXRhLnRpbWV0YWJsZS5yb3V0ZXNbMF0uc2NoZWR1bGVzICYmIGRhdGEudGltZXRhYmxlLnJvdXRlc1swXS5zY2hlZHVsZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRpbWVUYWJsZURhdGEgOiBBcnJheTxTY2hlZHVsZT4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IHNjaGVkdWxlIG9mIGRhdGEudGltZXRhYmxlLnJvdXRlc1swXS5zY2hlZHVsZXMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEhvdXIgPSAoTnVtYmVyKHNjaGVkdWxlLmxhc3RKb3VybmV5LmhvdXIpICUgMjQpICsgXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJ1c1NjaGVkdWxlOiBTY2hlZHVsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU6IHNjaGVkdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdDpzY2hlZHVsZS5maXJzdEpvdXJuZXkuaG91ciArIFwiOlwiICsgc2NoZWR1bGUuZmlyc3RKb3VybmV5Lm1pbnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Q6IGxhc3RIb3VyICsgXCI6XCIgKyBzY2hlZHVsZS5sYXN0Sm91cm5leS5taW51dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lVGFibGVEYXRhLnB1c2goYnVzU2NoZWR1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0vL2ZvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGltZVRhYmxlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoXCJCdXMgbGluZSBzdGF0aW9ucyB0aW1lIHRhYmxlIGRhdGEgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFwiQnVzIGxpbmUgc3RhdGlvbnMgdGltZSB0YWJsZSBkYXRhIGVycm9yXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChcIkNhbiBub3QgZ2V0IGJ1cyBsaW5lIHN0YXRpb25zIHRpbWUgdGFibGUgaW5mbyBmcm9tIEFQSVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJMb25kb24gVHJhbnNwb3J0IEFQSSBlcnJvcjogXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgIH1cbn0iXX0=